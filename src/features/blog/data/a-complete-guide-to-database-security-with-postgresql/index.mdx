export const author = "Flavio Silva";

export const authorImage = "flavio-thumb.jpg";

export const authorUrl = "https://www.flsilva.com";

export const changefreq = "monthly";

export const contentType = "blog-post";

export const date = "2025-04-17T00:00:00";

export const description =
  "Learn comprehensive PostgreSQL database security strategies, from authentication and role-based access to encryption and audit logging. Implement defense-in-depth protection for your sensitive data.";

export const heroImage = "hero.png";

export const heroImageCreditText = "";

export const heroImageCreditUrl = "";

export const heroImageWidth = 853;

export const heroImageHeight = 517;

export const priority = 0.6;

export const slug = "a-complete-guide-to-database-security-with-postgresql";

export const tags = ["database", "sql", "postgresql"];

export const title = "A complete guide to database security with PostgreSQL";

export const tweetText =
  "Discover how to implement bulletproof security for your PostgreSQL database! This comprehensive guide covers authentication, role-based access control, row-level security, data encryption, and audit logging to protect your sensitive information from unauthorized access. #PostgreSQL #DatabaseSecurity #DataProtection";

export const tweetVia = "flsilva7";

export const tweetCardImage = "tweet-card.png";

import { ImageWithCaption } from "@/features/shared/ui/ImageWithCaption";
import { SocialMediaShareButtons } from "@/features/shared/ui/social-media-share/SocialMediaShareButtons";
import { AITools } from "@/features/shared/ui/boxes/AITools";
import { InfoBox } from "@/features/shared/ui/boxes/InfoBox";
import { InfoBoxQuotation } from "@/features/shared/ui/boxes/InfoBoxQuotation";
import { A } from "@/features/shared/ui/typography/Typography";

<br />
<br />

<InfoBox>
  This is **Part 14** of the "Mastering Relational Database Design" series. In
  [Part 13](LINK_HERE), we learned how transactions work, the ACID properties
  that define reliable transactions, and practical implementation strategies for
  maintaining data integrity in our ShopSmart ecommerce system.
</InfoBox>

## Introduction

Database security is a critical aspect of database design and management that protects data from unauthorized access, corruption, or loss. Security breaches can lead to exposure of sensitive customer information, financial fraud, regulatory penalties, and damage to your organization's reputation.

In this article, we'll explore comprehensive strategies for securing your PostgreSQL database. We'll examine authentication mechanisms, role-based access control, encryption options, audit logging, and other security features that help protect your data from various threats.

## Core security principles

Before diving into specific techniques, let's establish some fundamental security principles that should guide your approach:

### Principle of Least Privilege (PoLP)

The [Principle of Least Privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege) states that users, applications, and processes should have only the minimum access rights necessary to perform their functions. This limits the potential damage from accidents, errors, or malicious actions.

<InfoBoxQuotation>
  Grant the minimum permissions needed to do the job—nothing more. Every
  additional permission increases your attack surface and potential for data
  breaches.
</InfoBoxQuotation>

In practice, this means:

- Creating specific roles with limited permissions.
- Avoiding use of superuser accounts for routine operations.
- Regularly reviewing and adjusting permissions.

### Defense in Depth

[Defense in Depth](<https://en.wikipedia.org/wiki/Defense_in_depth_(computing)>) involves implementing multiple layers of security controls throughout your database system. If one layer fails, others still provide protection.

For a PostgreSQL database, defense in depth might include:

- Network-level protections (firewalls, VPNs)
- Authentication controls
- Role-based access restrictions
- Schema-level security
- Row and column-level security
- Encryption of sensitive data
- Audit logging and monitoring

### Regular auditing

Security is not a one-time setup but an ongoing process. Regular auditing helps identify potential vulnerabilities, ensure compliance with security policies, and detect unauthorized access attempts.

Effective auditing includes:

- Reviewing user accounts and permissions.
- Monitoring login attempts and unusual access patterns.
- Examining database logs for suspicious activity.
- Testing security controls through penetration testing.

With these principles in mind, let's explore specific security features and implementation strategies for PostgreSQL.

## Authentication

Authentication is the process of verifying the identity of users or systems attempting to connect to your database. PostgreSQL offers several authentication methods configured in the _`pg_hba.conf`_ file (HBA stands for "host-based authentication").

### Password authentication

Password authentication is the most common method. In PostgreSQL, passwords should be stored using secure hashing algorithms:

```sql
-- Create a user with a password
CREATE USER app_user WITH PASSWORD 'secure_password_here';

-- Set password encryption method to SCRAM-SHA-256 (PostgreSQL 10+)
SET password_encryption = 'scram-sha-256';

-- Update a user's password
ALTER USER app_user WITH PASSWORD 'new_secure_password';
```

For production environments, use the _`scram-sha-256`_ encryption method which is more secure than the older _`md5`_ method.

<InfoBox>
  Never store database passwords in application code or version control
  repositories. Instead, use [environment
  variables](https://en.wikipedia.org/wiki/Environment_variable), secure
  credential stores, or dedicated secrets management services to provide
  passwords to applications at runtime.
</InfoBox>

### Certificate authentication

For higher security, PostgreSQL supports client certificate authentication:

1. Configure PostgreSQL for SSL/TLS:

```
# in postgresql.conf
ssl = on
ssl_cert_file = 'server.crt'
ssl_key_file = 'server.key'
ssl_ca_file = 'root.crt'    # CA that signed client certificates
```

2. Create users with certificate authentication:

```sql
CREATE USER cert_user;
```

3. Configure `pg_hba.conf` to require certificates:

```
hostssl all cert_user all cert clientcert=verify-full
```

This method eliminates the need for passwords, relying instead on cryptographic certificates for authentication.

### External authentication

PostgreSQL can integrate with external authentication systems:

1. **LDAP Authentication**: Authenticate against corporate directory services:

```
hostssl all ldap_users all ldap ldapserver=ldap.example.com ldapprefix="uid=" ldapsuffix=",ou=people,dc=example,dc=com"
```

2. **GSSAPI/Kerberos**: For integration with enterprise single sign-on systems:

```
hostssl all gssapi_users all gss
```

3. **PAM Authentication**: Use the system's Pluggable Authentication Module:

```
hostssl all pam_users all pam
```

External authentication simplifies user management and creates a more streamlined login experience in enterprise environments.

## Authorization: role-based access control

Once users are authenticated, authorization controls what they can access and what operations they can perform. PostgreSQL implements this through its role system.

### Creating roles with appropriate privileges

PostgreSQL uses roles (which can be users or groups) to manage permissions:

```sql
-- Create application roles
CREATE ROLE readonly_user;
CREATE ROLE data_analyst;
CREATE ROLE customer_service;
CREATE ROLE order_processor;
CREATE ROLE admin_user;

-- Grant appropriate privileges to each role
GRANT CONNECT ON DATABASE shopsmartdb TO readonly_user;
GRANT USAGE ON SCHEMA customers, products, orders TO readonly_user;
GRANT SELECT ON ALL TABLES IN SCHEMA customers, products, orders TO readonly_user;

-- More specific permissions for data analysts
GRANT CONNECT ON DATABASE shopsmartdb TO data_analyst;
GRANT USAGE ON SCHEMA analytics TO data_analyst;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA analytics TO data_analyst;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA analytics TO data_analyst;

-- Customer service role with limited write access
GRANT CONNECT ON DATABASE shopsmartdb TO customer_service;
GRANT USAGE ON SCHEMA customers, orders TO customer_service;
GRANT SELECT ON ALL TABLES IN SCHEMA customers, orders TO customer_service;
GRANT UPDATE (email, phone, first_name, last_name) ON customers.customers TO customer_service;
GRANT UPDATE (status) ON orders.orders TO customer_service;
```

This creates a set of roles with increasingly specific permissions aligned with job functions.

### Role inheritance

PostgreSQL roles can inherit permissions from other roles, creating a hierarchy:

```sql
-- Create a base role with common permissions
CREATE ROLE app_user;
GRANT CONNECT ON DATABASE shopsmartdb TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;

-- Create specialized roles that inherit from app_user
CREATE ROLE sales_staff IN ROLE app_user;
CREATE ROLE warehouse_staff IN ROLE app_user;

-- Grant additional specific permissions to specialized roles
GRANT SELECT ON orders.orders TO sales_staff;
GRANT UPDATE ON inventory.stock_levels TO warehouse_staff;

-- Create actual user accounts that inherit from role groups
CREATE USER alice WITH PASSWORD 'secure_pwd1' IN ROLE sales_staff;
CREATE USER bob WITH PASSWORD 'secure_pwd2' IN ROLE warehouse_staff;
```

Role inheritance simplifies permission management by allowing you to organize privileges in a hierarchical manner.

### Default privileges

To ensure new objects automatically receive appropriate permissions:

```sql
-- Set default privileges for objects created in the future
ALTER DEFAULT PRIVILEGES IN SCHEMA customers
GRANT SELECT ON TABLES TO readonly_user;

ALTER DEFAULT PRIVILEGES IN SCHEMA analytics
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO data_analyst;

ALTER DEFAULT PRIVILEGES FOR ROLE schema_owner IN SCHEMA products
GRANT SELECT ON TABLES TO app_user;
```

Default privileges ensure that security policies apply consistently as the database evolves, reducing the risk of accidentally exposed data when new tables or functions are created.

## Schema-level security

As we discussed in our article on schemas, organizing database objects into schemas provides natural security boundaries:

```sql
-- Create schemas with appropriate ownership
CREATE SCHEMA customers AUTHORIZATION admin_user;
CREATE SCHEMA orders AUTHORIZATION admin_user;
CREATE SCHEMA analytics AUTHORIZATION analytics_admin;

-- Grant schema-level permissions
GRANT USAGE ON SCHEMA customers TO customer_service;
GRANT USAGE ON SCHEMA orders TO order_processor;
GRANT USAGE ON SCHEMA analytics TO data_analyst;

-- Revoke public access from sensitive schemas
REVOKE ALL ON SCHEMA customers FROM PUBLIC;
REVOKE ALL ON SCHEMA orders FROM PUBLIC;
```

Using schemas for security compartmentalization:

- Creates logical separation between different parts of the application.
- Simplifies permission management.
- Prevents accidental access to sensitive data.
- Aligns security boundaries with business domains.

## Row-level security (RLS)

PostgreSQL's [Row-Level Security (RLS)](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) feature allows fine-grained access control to rows in a table based on the user executing the query. This is particularly powerful for multi-tenant applications or systems where data access depends on user attributes.

### Implementing RLS for customer data

Let's implement RLS in our ShopSmart database to ensure that customer service representatives can only view orders from customers they are assigned to:

```sql
-- First, create a table to track customer assignments
CREATE TABLE customers.customer_representatives (
    customer_id uuid NOT NULL REFERENCES customers.customers(customer_id),
    rep_id uuid NOT NULL REFERENCES staff.representatives(rep_id),
    assigned_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (customer_id, rep_id)
);

-- Enable RLS on the orders table
ALTER TABLE orders.orders ENABLE ROW LEVEL SECURITY;

-- Create a policy that restricts customer service reps to only see orders
-- from customers they are assigned to
CREATE POLICY customer_rep_orders ON orders.orders
    FOR SELECT
    USING (customer_id IN (
        SELECT customer_id FROM customers.customer_representatives
        WHERE rep_id = current_setting('app.current_rep_id')::uuid
    ));

-- Create a policy for regional managers to see all orders from their region
CREATE POLICY region_manager_orders ON orders.orders
    FOR SELECT
    USING ((
        SELECT region_id FROM customers.customers WHERE customer_id = orders.customer_id
    ) IN (
        SELECT region_id FROM staff.region_managers
        WHERE manager_id = current_setting('app.current_manager_id')::uuid
    ));

-- Create a catch-all policy for administrators
CREATE POLICY admin_orders ON orders.orders
    FOR ALL
    USING (pg_has_role(current_user, 'administrator', 'member'));
```

To use RLS effectively:

1. Set the application context before executing queries:

```sql
SET app.current_rep_id = '42';
```

2. Create appropriate roles and grant them to users:

```sql
CREATE ROLE customer_rep;
GRANT customer_rep TO user1, user2;
```

3. Ensure all tables with sensitive data have RLS enabled and appropriate policies.

<InfoBoxQuotation>
  Row-Level Security moves access control from the application to the database,
  ensuring consistent enforcement regardless of how data is accessed—whether
  through the application, API, or direct database connections.
</InfoBoxQuotation>

### RLS for multi-tenant applications

For multi-tenant applications where data from multiple customers is stored in the same tables:

```sql
-- Enable RLS on all tenant-specific tables
ALTER TABLE customers.customers ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE products.products ENABLE ROW LEVEL SECURITY;

-- Create a policy that restricts access based on tenant ID
CREATE POLICY tenant_isolation ON customers.customers
    FOR ALL
    USING (tenant_id = current_setting('app.current_tenant_id')::uuid);

-- Similar policies for other tables
CREATE POLICY tenant_isolation ON orders.orders
    FOR ALL
    USING (tenant_id = current_setting('app.current_tenant_id')::uuid);
```

This approach ensures complete tenant isolation while maintaining a single database schema for all tenants.

## Column-level security

To restrict access to specific columns containing sensitive data:

### Using views for column security

```sql
-- Create a view that excludes sensitive columns
CREATE VIEW customers.customer_limited_view AS
SELECT
    customer_id,
    first_name,
    last_name,
    email,
    -- Exclude sensitive fields like credit_score, income_bracket, etc.
    created_at
FROM
    customers.customers;

-- Grant access to the view, not the underlying table
REVOKE ALL ON customers.customers FROM marketing_team;
GRANT SELECT ON customers.customer_limited_view TO marketing_team;
```

### Using column privileges

PostgreSQL also allows granting permissions at the column level:

```sql
-- Grant access only to specific columns
GRANT SELECT (customer_id, first_name, last_name, email) ON customers.customers TO support_staff;

-- Allow updates only on non-sensitive columns
GRANT UPDATE (email, phone, address_id) ON customers.customers TO support_staff;
```

This approach is particularly useful for compliance with data protection regulations that require limiting access to personally identifiable information (PII).

## Data encryption

Encryption protects data confidentiality, ensuring that even if unauthorized access occurs, the data remains unreadable. PostgreSQL offers several encryption capabilities:

### Connection encryption with SSL/TLS

Configure PostgreSQL to use SSL/TLS for all connections in _`postgresql.conf`_:

```
ssl = on
ssl_cert_file = 'server.crt'
ssl_key_file = 'server.key'
ssl_ciphers = 'HIGH:!aNULL:!MD5'
```

And force SSL connections in _`pg_hba.conf`_:

```
hostssl all all all scram-sha-256
```

### Encryption at rest

For full database encryption at rest, use filesystem or disk encryption such as:

- Linux Unified Key Setup (LUKS).
- Transparent Data Encryption (TDE) solutions.
- Cloud provider encryption services (AWS EBS encryption, Azure Disk Encryption).

### Column-level encryption

For sensitive fields like credit card numbers or social security numbers:

```sql
-- Using pgcrypto extension for column encryption
CREATE EXTENSION pgcrypto;

-- Create a table with encrypted columns
CREATE TABLE payments.credit_cards (
    card_id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    customer_id uuid NOT NULL REFERENCES customers.customers(customer_id),
    card_number_encrypted bytea NOT NULL,
    expiry_date_encrypted bytea NOT NULL,
    cardholder_name varchar(100) NOT NULL,
    created_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Function to encrypt card data
CREATE OR REPLACE FUNCTION payments.encrypt_card_data(card_number text, encryption_key text)
RETURNS bytea AS $$
BEGIN
    RETURN pgp_sym_encrypt(card_number, encryption_key);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to decrypt card data
CREATE OR REPLACE FUNCTION payments.decrypt_card_data(encrypted_data bytea, encryption_key text)
RETURNS text AS $$
BEGIN
    RETURN pgp_sym_decrypt(encrypted_data, encryption_key);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Example usage
INSERT INTO payments.credit_cards (
    customer_id,
    card_number_encrypted,
    expiry_date_encrypted,
    cardholder_name
) VALUES (
    'customer123',
    payments.encrypt_card_data('4111111111111111', 'encryption_key_here'),
    payments.encrypt_card_data('12/25', 'encryption_key_here'),
    'John Doe'
);

-- Retrieving decrypted data (with proper authorization)
SELECT
    customer_id,
    payments.decrypt_card_data(card_number_encrypted, 'encryption_key_here') AS card_number,
    payments.decrypt_card_data(expiry_date_encrypted, 'encryption_key_here') AS expiry_date,
    cardholder_name
FROM
    payments.credit_cards
WHERE
    customer_id = 'customer123';
```

<InfoBox>
  Store encryption keys securely outside the database using a key management
  system (KMS). Never store encryption keys in the same database as the
  encrypted data, as this defeats the purpose of encryption.
</InfoBox>

### Data masking

For situations where data must be visible but partially obscured:

```sql
-- Create a function to mask credit card numbers
CREATE OR REPLACE FUNCTION payments.mask_card_number(card_number text)
RETURNS text AS $$
BEGIN
    RETURN 'XXXX-XXXX-XXXX-' || RIGHT(card_number, 4);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Create a view with masked data
CREATE VIEW payments.masked_payment_methods AS
SELECT
    payment_method_id,
    customer_id,
    payments.mask_card_number(card_number) AS masked_card_number,
    card_type,
    expiry_month,
    expiry_year
FROM
    payments.payment_methods;
```

Data masking is particularly useful for support staff who need to reference accounts without seeing full sensitive details.

## Audit logging

Audit logging records database activities to detect suspicious behavior, track changes, and comply with regulatory requirements. PostgreSQL offers several options for audit logging:

### Using PostgreSQL's built-in logging

Configure _`postgresql.conf`_ for basic auditing:

```
log_destination = 'csvlog'
logging_collector = on
log_directory = 'pg_log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_statement = 'mod'       # Logs all data-modifying statements
log_min_duration_statement = 1000  # Log all statements running at least 1 second
```

### Creating a custom audit system

For more comprehensive auditing, implement a trigger-based audit system:

```sql
-- Create audit log table
CREATE TABLE system.audit_log (
    audit_id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    table_name varchar(50) NOT NULL,
    operation varchar(10) NOT NULL CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE')),
    record_id uuid NOT NULL,
    changed_by varchar(50) NOT NULL,
    changed_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    old_values jsonb,
    new_values jsonb
);

-- Create a generic audit trigger function
CREATE OR REPLACE FUNCTION system.audit_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        INSERT INTO system.audit_log (
            table_name, operation, record_id, changed_by,
            old_values, new_values
        ) VALUES (
            TG_TABLE_NAME, TG_OP, OLD.id, current_user,
            to_jsonb(OLD), to_jsonb(NEW)
        );
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO system.audit_log (
            table_name, operation, record_id, changed_by,
            old_values
        ) VALUES (
            TG_TABLE_NAME, TG_OP, OLD.id, current_user,
            to_jsonb(OLD)
        );
        RETURN OLD;
    ELSIF TG_OP = 'INSERT' THEN
        INSERT INTO system.audit_log (
            table_name, operation, record_id, changed_by,
            new_values
        ) VALUES (
            TG_TABLE_NAME, TG_OP, NEW.id, current_user,
            to_jsonb(NEW)
        );
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Apply audit trigger to sensitive tables
CREATE TRIGGER audit_customers_trigger
AFTER INSERT OR UPDATE OR DELETE ON customers.customers
FOR EACH ROW EXECUTE FUNCTION system.audit_trigger_function();

CREATE TRIGGER audit_orders_trigger
AFTER INSERT OR UPDATE OR DELETE ON orders.orders
FOR EACH ROW EXECUTE FUNCTION system.audit_trigger_function();
```

This creates a comprehensive audit trail that records who changed what data and when, along with both old and new values.

### Dedicated audit extensions

Consider using dedicated audit extensions for PostgreSQL:

1. **pgAudit**: Provides detailed session and object audit logging:

```
shared_preload_libraries = 'pgaudit'
pgaudit.log = 'write,ddl'
pgaudit.log_relation = on
pgaudit.log_catalog = off
```

2. **pg_stat_statements**: Tracks query execution statistics:

```
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.track = all
```

These extensions provide more comprehensive auditing capabilities than DIY solutions, with better performance and lower overhead.

## Secure database administration

Securing the database goes beyond code and configuration—administrative practices also play a crucial role:

### Limiting superuser access

Minimize the use of superuser accounts (like `postgres`):

```sql
-- Create limited admin roles for specific purposes
CREATE ROLE backup_operator;
GRANT CONNECT ON DATABASE shopsmartdb TO backup_operator;
GRANT SELECT ON ALL TABLES IN SCHEMA public, customers, orders, products TO backup_operator;

CREATE ROLE schema_manager;
GRANT CREATE ON DATABASE shopsmartdb TO schema_manager;
```

### Secure connection methods

Restrict how administrators can connect to the database:

1. Configure `pg_hba.conf` to limit superuser connections to local or specific IPs:

```
# Allow local superuser connections only
local   all     postgres                    peer
# Remote connections require SSL and strong authentication
hostssl all     postgres    10.0.1.0/24     scram-sha-256
```

2. Set up SSH tunneling for remote administration:

```
ssh -L 5432:localhost:5432 db-server.example.com
```

3. Use a bastion host or VPN for database access.

### Regular security updates

Keep PostgreSQL and its extensions updated with security patches:

```bash
# Check current version
psql -c "SELECT version();"

# Update to latest minor version (example for Ubuntu/Debian)
sudo apt update
sudo apt upgrade postgresql-17  # Replace with your version
```

Set up monitoring to alert when security updates are available.

## Securing database backups

Database backups often contain all of your sensitive data and need strong protection:

### Encrypted backups

Create encrypted backups using tools like _`pgbackrest`_ or by encrypting standard _`pg_dump`_ output:

```bash
# Using encryption with pg_dump
pg_dump dbname | gpg -c > backup.sql.gpg

# Decrypting and restoring
gpg -d backup.sql.gpg | psql dbname
```

### Backup access controls

Implement strict access controls for backup files:

- Store backups in dedicated, access-controlled storage.
- Use separate credentials for backup systems.
- Implement retention policies aligned with data protection requirements.
- Regularly test backup restoration processes.

### Backup validation

Regularly validate the integrity and security of backups:

- Test restoration procedures to ensure backups are valid.
- Verify that sensitive data is properly protected in backups.
- Audit access to backup storage and restoration processes.

## Network security

Database security extends to the network layer:

### Firewall configuration

Restrict database access at the network level:

```
# Configure PostgreSQL to listen only on specific interfaces
listen_addresses = 'localhost,10.0.1.5'  # in postgresql.conf

# Set up firewall rules (example for ufw on Ubuntu)
sudo ufw allow from 10.0.1.0/24 to any port 5432
sudo ufw deny from any to any port 5432
```

### Using a connection pooler

A connection pooler like PgBouncer adds an additional security layer:

```ini
# pgbouncer.ini
[databases]
shopsmartdb = host=localhost port=5432 dbname=shopsmartdb

[pgbouncer]
listen_addr = *
listen_port = 6432
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt
admin_users = pgbouncer_admin
```

Connection poolers not only improve performance but can also provide:

- Additional authentication layers
- Connection limiting
- Protection against connection-based attacks

## Implementing security for ShopSmart

Let's apply these security principles to our ShopSmart ecommerce database, creating a comprehensive security implementation:

### 1. Create a secure role structure

```sql
-- Base roles for different job functions
CREATE ROLE shopper_service;   -- Customer service team
CREATE ROLE product_manager;   -- Product management team
CREATE ROLE order_processor;   -- Order fulfillment team
CREATE ROLE analytics_user;    -- Data analysis team
CREATE ROLE system_admin;      -- System administrators

-- Grant appropriate schema access
GRANT USAGE ON SCHEMA customers TO shopper_service;
GRANT USAGE ON SCHEMA products TO product_manager;
GRANT USAGE ON SCHEMA orders TO order_processor;
GRANT USAGE ON SCHEMA analytics TO analytics_user;
GRANT USAGE ON ALL SCHEMAS TO system_admin;

-- Grant appropriate table permissions
GRANT SELECT ON ALL TABLES IN SCHEMA customers TO shopper_service;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA products TO product_manager;
GRANT SELECT, UPDATE ON ALL TABLES IN SCHEMA orders TO order_processor;
GRANT SELECT ON ALL TABLES IN SCHEMA customers, products, orders TO analytics_user;

-- Create application roles
CREATE ROLE api_service WITH PASSWORD 'api_secure_password';
GRANT CONNECT ON DATABASE shopsmartdb TO api_service;
GRANT USAGE ON SCHEMA customers, products, orders TO api_service;
GRANT SELECT ON ALL TABLES IN SCHEMA customers, products, orders TO api_service;
GRANT INSERT, UPDATE ON orders.orders, orders.order_items TO api_service;

-- Create individual user accounts
CREATE USER john_support WITH PASSWORD 'johns_secure_pwd' IN ROLE shopper_service;
CREATE USER sarah_product WITH PASSWORD 'sarahs_secure_pwd' IN ROLE product_manager;
```

### 2. Implement row-level security for customer data

```sql
-- Enable RLS on customer tables
ALTER TABLE customers.customers ENABLE ROW LEVEL SECURITY;
ALTER TABLE customers.addresses ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders.orders ENABLE ROW LEVEL SECURITY;

-- Create policy for support team to only see assigned customers
CREATE POLICY customer_assignment ON customers.customers
    FOR ALL
    USING (
        customer_id IN (
            SELECT customer_id
            FROM customers.customer_assignments
            WHERE support_agent_id = current_setting('app.current_agent_id')::uuid
        )
        OR pg_has_role(current_user, 'system_admin', 'member')
    );

-- Apply similar policies to related tables
CREATE POLICY customer_addresses ON customers.addresses
    FOR ALL
    USING (
        customer_id IN (
            SELECT customer_id
            FROM customers.customer_assignments
            WHERE support_agent_id = current_setting('app.current_agent_id')::uuid
        )
        OR pg_has_role(current_user, 'system_admin', 'member')
    );
```

### 3. Encrypt sensitive customer data

```sql
-- Create extension for encryption
CREATE EXTENSION pgcrypto;

-- Add encrypted columns for sensitive data
ALTER TABLE customers.customers
ADD COLUMN payment_token_encrypted bytea,
ADD COLUMN tax_id_encrypted bytea;

-- Create encryption/decryption functions
CREATE OR REPLACE FUNCTION customers.encrypt_sensitive_data(data text, key text)
RETURNS bytea AS $$
BEGIN
    RETURN pgp_sym_encrypt(data, key);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION customers.decrypt_sensitive_data(encrypted_data bytea, key text)
RETURNS text AS $$
BEGIN
    RETURN pgp_sym_decrypt(encrypted_data, key);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 4. Set up comprehensive audit logging

```sql
-- Create audit log table
CREATE TABLE system.audit_log (
    audit_id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    table_schema varchar(50) NOT NULL,
    table_name varchar(50) NOT NULL,
    operation varchar(10) NOT NULL,
    record_id uuid,
    changed_by varchar(50) NOT NULL,
    changed_at timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
    client_ip inet,
    application_name text,
    old_values jsonb,
    new_values jsonb
);

-- Create audit function that captures additional context
CREATE OR REPLACE FUNCTION system.audit_trigger_function()
RETURNS TRIGGER AS $$
DECLARE
    record_id uuid;
    change_note text;
BEGIN
    -- Get the record identifier, handling different primary key names
    IF TG_OP = 'DELETE' THEN
        record_id := OLD.id;
        IF record_id IS NULL THEN
            record_id := OLD.customer_id;
        END IF;
        IF record_id IS NULL THEN
            record_id := OLD.order_id;
        END IF;
    ELSE
        record_id := NEW.id;
        IF record_id IS NULL THEN
            record_id := NEW.customer_id;
        END IF;
        IF record_id IS NULL THEN
            record_id := NEW.order_id;
        END IF;
    END IF;

    -- Get change note from application context if available
    BEGIN
        change_note := current_setting('app.audit_reason');
    EXCEPTION WHEN OTHERS THEN
        change_note := NULL;
    END;

    -- Create appropriate audit log entry
    IF TG_OP = 'UPDATE' THEN
        INSERT INTO system.audit_log (
            table_schema, table_name, operation, record_id, changed_by,
            client_ip, application_name, old_values, new_values
        ) VALUES (
            TG_TABLE_SCHEMA, TG_TABLE_NAME, TG_OP, record_id, current_user,
            inet_client_addr(), current_setting('application_name'),
            to_jsonb(OLD), to_jsonb(NEW)
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO system.audit_log (
            table_schema, table_name, operation, record_id, changed_by,
            client_ip, application_name, old_values
        ) VALUES (
            TG_TABLE_SCHEMA, TG_TABLE_NAME, TG_OP, record_id, current_user,
            inet_client_addr(), current_setting('application_name'),
            to_jsonb(OLD)
        );
    ELSIF TG_OP = 'INSERT' THEN
        INSERT INTO system.audit_log (
            table_schema, table_name, operation, record_id, changed_by,
            client_ip, application_name, new_values
        ) VALUES (
            TG_TABLE_SCHEMA, TG_TABLE_NAME, TG_OP, record_id, current_user,
            inet_client_addr(), current_setting('application_name'),
            to_jsonb(NEW)
        );
    END IF;

    -- Return appropriate value based on operation
    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Apply audit triggers to key tables
CREATE TRIGGER audit_customers
AFTER INSERT OR UPDATE OR DELETE ON customers.customers
FOR EACH ROW EXECUTE FUNCTION system.audit_trigger_function();

CREATE TRIGGER audit_orders
AFTER INSERT OR UPDATE OR DELETE ON orders.orders
FOR EACH ROW EXECUTE FUNCTION system.audit_trigger_function();

CREATE TRIGGER audit_payments
AFTER INSERT OR UPDATE OR DELETE ON orders.payments
FOR EACH ROW EXECUTE FUNCTION system.audit_trigger_function();
```

### 5. Create secure views for limited data access

```sql
-- Create a view for customer service with limited PII
CREATE VIEW customers.customer_service_view AS
SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    c.email,
    c.phone,
    -- Exclude sensitive fields
    c.created_at,
    a.city,
    a.state,
    a.country,
    COUNT(o.order_id) AS total_orders,
    MAX(o.ordered_at) AS last_order_date
FROM
    customers.customers c
LEFT JOIN
    customers.addresses a ON c.customer_id = a.customer_id AND a.is_default
LEFT JOIN
    orders.orders o ON c.customer_id = o.customer_id
GROUP BY
    c.customer_id, c.first_name, c.last_name, c.email, c.phone,
    c.created_at, a.city, a.state, a.country;

-- Grant access to the view instead of the base table
REVOKE ALL ON customers.customers FROM shopper_service;
GRANT SELECT ON customers.customer_service_view TO shopper_service;
```

## Security best practices checklist

Use this checklist to ensure comprehensive security for your PostgreSQL database:

### Authentication

- [ ] Use strong password policies with `scram-sha-256` encryption
- [ ] Implement SSL/TLS for all connections
- [ ] Consider certificate authentication for critical systems
- [ ] Integrate with external identity providers where appropriate

### Authorization

- [ ] Follow the principle of least privilege for all roles
- [ ] Create functional roles rather than per-user permissions
- [ ] Use schema-level security as a first line of defense
- [ ] Implement row-level security for multi-tenant or sensitive data
- [ ] Create secured views to limit access to sensitive columns

### Encryption

- [ ] Configure SSL/TLS for data in transit
- [ ] Implement column-level encryption for sensitive data
- [ ] Use data masking for support and testing environments
- [ ] Encrypt backups and protect encryption keys

### Auditing

- [ ] Configure PostgreSQL logging appropriately
- [ ] Implement trigger-based audit logging for sensitive tables
- [ ] Consider specialized audit extensions for comprehensive coverage
- [ ] Regularly review audit logs for suspicious activity

### Administration

- [ ] Limit superuser access
- [ ] Create administrative roles with limited permissions
- [ ] Configure network security (firewalls, VPNs)
- [ ] Keep PostgreSQL updated with security patches
- [ ] Secure backup storage and processes
- [ ] Conduct regular security reviews and penetration testing

### Application Security

- [ ] Use parameterized queries to prevent SQL injection
- [ ] Use connection pooling with application-specific credentials
- [ ] Implement application-level context for RLS
- [ ] Never store database credentials in application code

## Key takeaways

- **The principle of least privilege** minimizes your attack surface.
- **Defense in depth** protects your database through multiple security layers.
- **Role-based access control** simplifies permission management.
- **Schema-level security** creates natural security boundaries.
- **Row-level security** enables fine-grained access control.
- **Column-level security** protects sensitive data fields.
- **Encryption** ensures data confidentiality.
- **Audit logging** tracks activities and aids compliance.
- **Connection security** protects data in transit.
- **Regular security reviews** maintain your security posture over time.

## Next up in the series

In the final article of this series, [Full Case Study & Conclusion](LINK_HERE), we'll bring together all the concepts we've explored to present a complete database design for our ShopSmart ecommerce application. We'll summarize key learnings, provide additional resources for further study, and discuss how to apply these principles to your own database projects.

## Complete series

- SERIES ARTICLE 01 (This article.)
- [SERIES ARTICLE 02](/blog/SERIES ARTICLE 02)
- [SERIES ARTICLE 03](/blog/SERIES ARTICLE 03)
  …

## Bibliography

- "PostgreSQL Documentation" _The PostgreSQL Global Development Group_ , n.d. Web. 16 April 2025 &#60;<a href="https://www.postgresql.org/docs/" style={{ lineBreak: 'anywhere' }}>ht<span />tps://www.postgresql.org/docs/</a>&#62;

<br />
<br />
<br />

<AITools />
