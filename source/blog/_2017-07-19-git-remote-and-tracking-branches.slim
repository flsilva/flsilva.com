textile:

  If you're new to <a href="http://git-scm.com/" target="_blank">Git</a> or want to know a little more about its basics and its distributed model, do not hesitate to read my "Introduction to Git":/blog/introducing-git/.

  If you're not very familiar with Git branching, or you'd like to refresh your understanding about it, please head to "Git Branching and Merging":/blog/git-branching-and-merging/, then come back and move on.

  In this article you'll learn what are remote and tracking branches, how they work and how to use them.

  <div class="info-box">
  <span class="warning icon"></span>

  Do not type the <code class='inline' data-language='shell'>$</code> sign you see in the command examples. That's just an indicator that you should run the command that follows it in your command line tool.

  </div>

  h3(#what-are-remote-branches). What are Remote Branches?

  "Remote references are references to the state of branches on your remote repositories. They’re local branches that you can’t move; they’re moved automatically whenever you do any network communication." (Chacon 50)

  So a remote branch is a *local branch* (created in your local repo) that points to and contains a copy of a branch in some remote repo. It's also ready-only, so you cannot change it, it's supposed to be updated when we run a <code class='inline' data-language='shell'>fetch</code> command. A bit confusing? I know, it really is at a first look.

  h3(#working-with-remote-branches). Working With Remote Branches

  For the sake of learning, we'll create a very simple Git project/repo and play with it to better understand branching and remote branches. So now please create a new directory, add a couple files in it, and run <code class='inline' data-language='shell'>$ git init</code>. Now if you run <code class='inline' data-language='shell'>$ git status</code> you should see your files listed as __Untracked files__. So let's run <code class='inline' data-language='shell'>$ git add .</code>, and then <code class='inline' data-language='shell'>$ git commit -m "adding some files."</code>.  Nice, now we have a local repo with some files committed to it.

  Now, take the time to set up a remote repo. You can use <a href="http://github.com/" target="_blank">GitHub</a>, <a href="http://bitbucket.org/" target="_blank">Bitbucket</a>, or any other service you like. After you have setup your remote repo, let add a reference to it in your local repo. To do that, run a command like:

  <code class="inline">
  $ git remote add origin [your-remote-url-goes-here]
  </code>

  Note that we're giving that remote an alias of <code class="inline">origin</code>, but it could be anything we wanted. If you run <code class="inline">$ git remote</code> now you should see something like:

  <code class="inline">origin</code>

  If you want more info about your remote repo you can append <code class="inline">-v</code> option to that command:

  <code class="inline">$ git remote -v</code>

  In that case you should see something like:

  <pre><code data-language='shell'>
  origin   [your-remote-repo-url] (fetch)
  origin   [your-remote-repo-url] (push)
  </code></pre>

  Note that Git lists two references to it, one for reading from your remote repo (fetch), and another for writing to your remote repo (push).

  Nice, now we can push to our remote repo, so let's do just that:

  <code class="inline">$ git push origin master</code>

  You should see something like:

  <pre><code data-language='shell'>
  Counting objects...
  ...
  Writing objects: 100%...
  ...
   * [new branch]      master -> master
  </code></pre>
  
  That means the operation was successfully completed. Git should have created a __master__ branch in your remote repo, and created a reference to it in your local repo. That reference is our remote branch (remote __master__ branch in this case), created in our local repo. By default, when we push to a remote repo, and there's no remote branch setup for the local branch we're pushing, Git creates one for us automatically, and names it as: <code class="inline">remotes/remote-name/branch-name</code>. So if you run <code class="inline">$ git branch -r</code> now (<code class="inline">-r</code> option means __remote__), you should see something like:

  <code class="inline">remotes/origin/master</code>

  You can also run <code class="inline">$ git branch -a</code> to see all branches, local and remote. In that case, you should see something like:

  <pre><code data-language='shell'>
  * master
    remotes/origin/master
  </code></pre>
  
  Your remote branch (<code class="inline">remotes/origin/master</code> in this case) is a copy of your remote repo's __master__ branch. At this time they are the same, but when you work on a project with other members, they will also update the project's remote repo, so your remote branch (your local copy of a branch living in a remote repo) will become outdated at some point. Just keep that in mind for now.
  
  Now, you can really switch to that remote branch if you want by running:

  <code class="inline">$ git checkout origin/master</code>

  You should see some output, including something like __Note: checking out 'origin/master'__. Note that you can omit <code class="inline">remotes/</code> prefix when referring to remote branches.

  What's coolest is that it's a local operation, because you have a copy of the contents of your remote repo's __master__ branch exactly as it is. Nice, isn't it?

  Cool, now I feel you have a better understanding about what is a remote branch. Now, let's see why we need remote branches.
  
  h3(#why-we-need-remote-branches). Why Do We Need Remote Branches?

  We know that to send our local changes to a remote repository we run a <code class="inline">push</code> command. But It's a good practice to always run a <code class="inline">fetch</code> command *before* <code class="inline">push</code>, as we've seen "here":/blog/git-basic-commands-explained/#fetching-changes-from-a-remote-repository. The only exception is when we're pushing a new branch to our remote repo, effectively creating that new branch in our remote repo. In that case, since that branch didn't exist in that remote repo yet, there's nothing to fetch from it.

  A <code class="inline">fetch</code> command synchronizes our local repo with a remote repo:

  <code class="inline">$ git fetch [remote-name]</code>

  By synchronize we understand a copy of all branches in the remote repo to our local repo *as remote branches*. If a remote branch already exists in our local repo, it is updated. But that command will not touch our local branches (__master__, etc), only our remote ones (<code class="inline">origin/master</code>, etc). So our __master__ branch will keep outdated if we get new changes from our remote repo when we run <code class="inline">fetch</code>.

  Why do you need to run <code class="inline">fetch</code> before push?

  If someone else has pushed content to a remote repo, you need to <code class="inline">fetch</code> those changes first, and <code class="inline">merge</code> them into your local branch. Only then you can <code class="inline">push</code> your changes. Git doesn't allow us to push our changes to a remote repo if our local branch is outdated in relation to our target branch living in a remote repo. In other words, if someone else has updated our remote repo's __master__ branch, we first need to merge those changes into our local __master__ branch, and only then push our changes. Note that you don't need to worry about branches that other people are pushing to a remote repo if you're not working on them.

  Since we're not working in any real project right now, let's simulate another person working on our project, and pushing changes. To do that, you can create another folder in your filesystem (outside your current repo, so not a subfolder of it), and clone your remote repo into it by running:

  <code class="inline">$ git clone [your-remote-url-goes-here]</code>

  Now, point to that new repo in your command line tool, make some small changes to any file, then commit and push it:

  <pre><code data-language='shell'>
  $ git add .
  $ git commit -m "some change from cloned repo."
  $ git push origin master
  </code></pre>

  You should see some output, including __Writing objects: 100__%. Nice, everything is ok. Now, let's move our command line tool back to point to the first repo we created, the one we started by using <code class='inline' data-language='shell'>$ git init</code>.

  At this point you should note that this first repo is now outdated, as our remote repo was just updated __by another guy__. Now, make some other change, to another file (or to the same file but on a different line just so we don't get any conflicts), add it, commit it, and try to push it:

  <pre><code data-language='shell'>
  $ git add .
  $ git commit -m "some change from init repo."
  $ git push origin master
  </code></pre>

  You should see an error message like:

  <pre><code data-language='shell'>
  To [your-remote-url]
   ! [rejected]        master -> master (fetch first)
  error: failed to push some refs to '[your-remote-url]'
  hint: Updates were rejected because the remote contains work that you do not have locally.
  </code></pre>
  
  Yup, that's expected. So let's fetch those changes by running <code class='inline' data-language='shell'>$ git fetch origin</code>. You should see some output, including something like __Unpacking objects: 100%__. Nice, now our (local) remote branch <code class='inline' data-language='shell'>origin/master</code> is updated with the contents of our remote repo's __master__ branch. So, let's now merge those changes into our local __master__ branch by running:

  <code class='inline' data-language='shell'>$ git merge origin/master</code>

  That should launch your system's default text editor with Git's default merge commit message, something like __Merge remote-tracking branch 'origin/master'__. Just save and close it. If for some reason you get an error message like:

  <pre><code data-language='shell'>
  error: There was a problem with the editor 'vi'.
  Not committing merge; use 'git commit' to complete the merge.
  </code></pre>

  Don't worry, you just have to commit it manually, in that case just run:

  <code class='inline' data-language='shell'>$ git commit -m "Merge remote-tracking branch 'origin/master'"</code>
  
  Nice! Your local __master__ branch is now up to date with <code class='inline' data-language='shell'>origin/master</code>, and ready to be pushed, so let's do that:

  <code class='inline' data-language='shell'>$ git push origin master</code>

  You should see a successful message, including __Writing objects: 100%__.

  And that's it for remote branches. That's a pretty common Git flow that you're probably going through when working alongside other people on the same remote repo.

  *Remember*: you only have to worry about merging remote changes if there were changes committed to the remote repo by another person, so changes that you do not have in your local repo yet.

  Now, let's take a look at a closely related topic: tracking branches.

  h3(#what-are-tracking-branches). What Are Tracking Branches?

  "Tracking branches are local branches that have a direct relationship to a remote branch. If you’re on a tracking branch and run git push, Git automatically knows which server and branch to push to." (Chacon 57)

  A tracking branch is just your regular local branch, but with some extra tracking information. It tells your local branches to track remote branches.

  h3(#working-with-tracking-branches). Working With Tracking Branches

  Let's continue playing with our local repo. Make sure that you point your command line tool to your local repo that you started by running <code class='inline' data-language='shell'>$ git init</code>, not the one you cloned (this is important). Now, change some file, add and commit it. Now, just try to run <code class='inline' data-language='shell'>$ git push</code>. You should see an error message like:

  <pre><code data-language='shell'>
  fatal: The current branch master has no upstream branch.
  To push the current branch and set the remote as upstream, use

      git push --set-upstream origin master
  </code></pre>

  That means Git doesn't know where to push your local branch to. It doesn't know which remote repo to use, and how it should name it in the target repo (you can push your local __master__ branch using a different name, Git doesn't assumes you want to use the same name).
  
  So far, we've been running <code class='inline' data-language='shell'>push</code> like so:

  <code class='inline' data-language='shell'>$ git push origin master</code>

  That tells Git to push our current branch to our <code class='inline' data-language='shell'>origin</code> remote and name it <code class='inline' data-language='shell'>master</code>. If such branch exists in our remote repo, it's updated, otherwise it's created.

  Cool, so now we'll make our local __master__ branch to track our remote __master__ branch. Git told us how to do that in that error message:

  <code class='inline' data-language='shell'>$ git push --set-upstream origin master</code>

  But there's a shorthand for that command:

  <code class='inline' data-language='shell'>$ git push -u origin master</code>

  You can do that at any time. If you don't have local changes to push, Git returns a message like __Everything up-to-date__ as usual, but in this case, since we're providing a <code class='inline' data-language='shell'>-u</code> parameter it also returns a message like __Branch master set up to track remote branch master from origin__. Nice, looks like it worked!

  Let's make sure that really worked. Let's make one more change to a file, add and commit it. Now, let's try to push without providing a <code class='inline' data-language='shell'>remote-name</code> and <code class='inline' data-language='shell'>branch-name</code>:

  <code class='inline' data-language='shell'>$ git push</code>

  You should see a regular success message. Awesome! Now you have your __master__ branch tracking your remote __master__ branch, and can easily pull and push to it without having to provide <code class='inline' data-language='shell'>remote-name</code> and <code class='inline' data-language='shell'>branch-name</code> every time. Nice, huh?

  When  you create new branches, you can append <code class='inline' data-language='shell'>-u</code> when you first push it to your remote repo, like:

  <code class='inline' data-language='shell'>$ git push -u your-remote-name your-branch-name</code>

  There's no problem if you forget to do that the first time you push your new branch to your remote repo, you can do that at any time.

  Another advantage of having tracking branches is that they show you when you are __ahead__ or __behind__ your remote branch when you run <code class='inline' data-language='shell'>$ git status</code>, meaning you need to push your changes. The following is a typical output of <code class='inline' data-language='shell'>$ git status</code> from a __master__ branch that IS NOT a tracking one, and there are no local changes:

  <pre><code data-language='shell'>
  On branch master
  nothing to commit, working tree clean
  </code></pre>

  Now, if that branch is a tracking one, you'd see something like:

  <pre><code data-language='shell'>
  On branch master
  Your branch is up-to-date with 'origin/master'.
  nothing to commit, working tree clean
  </code></pre>

  Did you notice that extra line? It says your branch is up-to-date with your remote branch. But there's a gotcha here: if someone else updates your remote repo, you'll still get that message, because Git is looking at your local remote branch (<code class='inline' data-language='shell'>remotes/origin/master</code>), not going to your remote repo to look at that branch there. If you run <code class='inline' data-language='shell'>$ git fetch</code>, your local remote branch will be updated, then if you run <code class='inline' data-language='shell'>$ git status</code> again, you should see something like:
  
  <pre><code data-language='shell'>
  On branch master
  Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
    (use "git pull" to update your local branch)
  nothing to commit, working tree clean
  </code></pre>

  Git tells you that you're behind <code class='inline' data-language='shell'>origin/master</code>, and that you can run <code class='inline' data-language='shell'>$ git pull</code> to update your local branch.

  Now, when you make local changes, commit them, and run <code class='inline' data-language='shell'>$ git status</code> *before* pushing your changes, you should see a message like:

  <pre><code data-language='shell'>
  On branch master
  Your branch is ahead of 'origin/master' by 1 commit.
    (use "git push" to publish your local commits)
  nothing to commit, working tree clean
  </code></pre>
  
  Git tells you that you're ahead of <code class='inline' data-language='shell'>origin/master</code>, and that you can run <code class='inline' data-language='shell'>$ git push</code> to update your remote branch with your local changes.

  Now, one thing to note is that when you clone a repo, Git creates a remote branch on your new local repo for each branch that exists in that remote repo. It also creates your local default __master__ branch, as it does when we start a repo by running <code class='inline' data-language='shell'>$ git init</code>. But since it also adds a <code class='inline' data-language='shell'>origin</code> remote for you (a reference to a remote repo), pointing to the remote repo you cloned, it goes even further and sets up your just created local __master__ branch to track your remote __master__ branch, which points to your <code class='inline' data-language='shell'>origin</code> remote. Nice, isn't it? And how nice is getting to know some of the things Git does behind the scenes for us?

  Now, let's picture a scenario where you just cloned a repo that contains some branches. When you clone a repo, Git creates remote branches for you automatically, remember? But it doesn't create *local* branches for you except __master__. So let's consider you have to do some work on one of those remote branches, say <code class='inline' data-language='shell'>new-feature-a</code> branch.

  Let's pretend you see the following when you run <code class='inline' data-language='shell'>$ git branch -a</code> in that hypothetical repo:

  <pre><code data-language='shell'>
  * master
    remotes/origin/master
    remotes/origin/new-feature-a
    remotes/origin/new-feature-b
  </code></pre>

  Ok, so you know there is a <code class='inline' data-language='shell'>new-feature-a</code> branch created in your remote repo by someone else, and you need to work on it, but you don't have such local branch yet. In that case what you want is kind of clone that remote branch, getting a local branch containing a copy of it, and why not, making it a tracking branch of that remote one. That looks like a lot of things, but you can do all of that with a single command:

  <code class='inline' data-language='shell'>$ git checkout -b [your-local-branch-name] [remote-name/branch-name]</code>

  Note that you can name your local branch anything you want, but most of the times you'll want to match your remote branch's name. In our hypothetical case, we'd do so by running:

  <code class='inline' data-language='shell'>$ git checkout -b new-feature-a origin/new-feature-a</code>

  You should see an output like:

  <pre><code data-language='shell'>
  Branch new-feature-a set up to track remote branch new-feature-a from origin.
  Switched to a new branch 'new-feature-a'
  </code></pre>

  That command creates a local <code class='inline' data-language='shell'>new-feature-a</code> branch with the same content of <code class='inline' data-language='shell'>origin/new-feature-a</code>, and makes it a tracking branch of <code class='inline' data-language='shell'>origin/new-feature-a</code>.

  h3(#conclusion). Conclusion

  That's it. You can now say that you know what remote and tracking branches are! Cool, right? But don't worry if things are still a little confusing. As a next step you should practice it a lot. Play with commands, create repositories, branches, merges, conflicts (and solve them!), and hopefully everything will look more natural in a few days.

  h3(#related-posts). Related Posts

  "Git Branching and Merging":/blog/git-branching-and-merging/
  "Git Basic Commands Explained":/blog/git-basic-commands-explained/
  "Git Workflow":/blog/git-workflow/
  "Git Tagging":/blog/git-tagging/
  "Introduction to Git":/blog/introducing-git/

  h3(#interesting-links). Interesting Links

  <a href="http://git-scm.com/" target="_blank">Git</a>
  <a href="http://progit.org/book/" target="_blank">Pro Git Book</a>

  h3(#bibliography). Bibliography

  Chacon, Scott. _Pro Git_. Apress, 2009.
